·### 1.
事务中用（本事务）快照体现了很强的隔离性（不受其他事务的影响的程度），自然就解决了不可重复读问题，使用快照读的时候不会出现幻读，而使用当前读出现幻读

### 2.好好理解这个例子，体现了rr确实是可重复读的，并且存在幻读问题
场景回顾：账户冻结系统

表名: accounts
字段: id (主键), balance (余额), frozen (是否冻结，默认false)
初始数据:
(id=1, balance=50, frozen=false)
(id=2, balance=80, frozen=false)
事务目标 (TA): 找出所有 balance < 100 的账户，将它们冻结，最后再次确认被冻结的账户数量。
隔离级别: REPEATABLE READ (RR)
干扰事务 (TB): 插入一个新账户，余额90 (<100)，并立即提交。
操作时序与现象分析（重点：插入发生在TA更新 前 且已提交）

时间点 T1: TA 开始事务。

重要： 此时，InnoDB 为 TA 创建数据快照 Snapshot_V1。Snapshot_V1 包含的数据是：id=1 (bal=50), id=2 (bal=80)。（新账户 id=3 还不存在）
时间点 T2: TA 执行 SELECT COUNT(*) FROM accounts WHERE balance < 100; (快照读)

读取来源： Snapshot_V1 (事务开始时创建的快照)。
结果：2。(TA 认为有 2 个账户需要冻结)
时间点 T3: TB 开始并执行 INSERT INTO accounts (id, balance) VALUES (3, 90);

时间点 T4: TB COMMIT; (成功提交！此时 id=3 (bal=90) 成为最新已提交的数据，物理存在于表中)。

时间点 T5: TA 执行 UPDATE accounts SET frozen = true WHERE balance < 100; (当前读)

读取来源： 最新已提交的数据！不是 Snapshot_V1！
扫描过程： UPDATE 需要找到所有满足 balance < 100 的行进行更新。它扫描物理表：
找到 id=1 (bal=50, 满足条件) -> 设置 frozen=true。
找到 id=2 (bal=80, 满足条件) -> 设置 frozen=true。
找到 id=3 (bal=90, 满足条件) -> 设置 frozen=true。 (因为 TB 已提交，id=3 是已提交的最新数据)
影响行数：3。(引擎返回告诉TA更新了3行)
物理效果： id=1, id=2, id=3 这三条记录的 frozen 字段在物理存储中都已被设置为 true。
关键矛盾点 1： TA 的 UPDATE 看到了 并在 物理上修改了 TB 提交插入的 id=3。这个修改是真实且持久的。
时间点 T6: TA 执行 SELECT COUNT(*) FROM accounts WHERE balance < 100 AND frozen = true; (快照读)

读取来源： 仍然是 Snapshot_V1 (事务开始时创建的快照)！这是 RR 隔离级别的核心保证。
Snapshot_V1 的状态是什么？
只有 id=1 (bal=50, frozen=false) 和 id=2 (bal=80, frozen=false)。
id=3 不存在于 Snapshot_V1 中。
id=1 和 id=2 的 frozen 字段在快照中仍然是 false (因为 TA 的 UPDATE 发生在快照之后，快照不包含 TA 自己未提交的修改对于 SELECT 的可见性规则较为特殊，但在 RR 下，即使读取自己未提交的改变，对于未出现在快照中的行也是不可见的。更安全的解释是：快照读看不到 id=3 的存在本身，自然也看不到它的 frozen 状态)。
结果：0 (因为 Snapshot_V1 中的两条记录 frozen 都是 false，快照中不存在 id=3)。或者更可能的结果是 2 (如果查询只基于 balance < 100，忽略了 frozen，即 SELECT COUNT(*) FROM accounts WHERE balance < 100;。这时结果仍然是 2，因为快照里只有两条记录，且它们的 frozen 在快照里是 false，但这不影响计数)。
关键矛盾点 2： 这个 SELECT 看不到 id=3 的存在！它也看不到 id=1 和 id=2 在快照之后被更新为 frozen=true 的状态（如果查询包含 frozen=true 条件）！它只忠实反映了 Snapshot_V1 的状态。
时间点 T7: TA COMMIT; (提交后，它对 id=1, id=2, id=3 设置的 frozen=true 正式生效，其他事务可见)。

幻读现象的核心矛盾总结：

UPDATE (当前读) 做了什么？
看到了 TB 提交的 id=3（因为它读取最新数据）。
成功地、物理地修改了 id=3 (将其 frozen 设为 true)。
报告修改了 3 行。
紧接其后的 SELECT (快照读) 看到了什么？
看不到 id=3（因为它只读取事务开始时的快照 Snapshot_V1）。
如果查询包含 frozen=true，它看不到 id=1 和 id=2 的 frozen 状态已变为 true（快照里它们还是 false）。
即使查询不包含 frozen，它也只看到 2 条 balance < 100 的记录（快照里的 id=1 和 id=2）。
结果：
事务 TA 内部逻辑崩溃： TA 的 UPDATE 明明报告更新了 3 行（包括那个刚刚插入的账户），但它的 SELECT 却显示只有 2 个符合条件的账户存在，或者显示其中 0 个被冻结了（如果检查了 frozen状态）。这完全不符合 TA 的预期（冻结所有最初看到的余额不足账户）。
这就是幻读： 那个 id=3 就像个“幽灵”（幻影行）：
它影响了 UPDATE 的结果（被冻结了）。
但它对事务 TA 内部的 SELECT（快照读）完全不可见，仿佛不存在一样。
导致了 TA 内部状态（基于 SELECT 的认知）与实际执行效果（UPDATE 修改的行）严重不一致。
为什么说它是“读”现象？

幻读的核心在于 同一个查询条件 (balance < 100) 在事务内多次执行（一次在UPDATE前，一次在UPDATE后），后一次读（SELECT）没有“看到”前一次写（UPDATE）所依据的、包含了新插入行的完整数据集。 更准确地说，是 读操作（快照读）无法感知到写操作（当前读）所处理的、由其他事务插入的“幻影行”的存在及其造成的影响（即使该行已被本事务修改！）。

InnoDB RR 级别的间隙锁如何解决这个问题？

如果 balance 字段有索引，InnoDB 在执行 UPDATE ... WHERE balance < 100 时：

会定位到所有满足条件的现有行并加行锁。
更重要的是，它会在扫描的 balance 值范围（例如从 -∞ 到 100）的 间隙（Gaps） 上加 间隙锁（Gap Locks）。
间隙锁阻止了其他事务（如 TB）向 balance < 100 的范围（间隙）内插入任何新记录！
因此，在上述场景中，TB 的 INSERT ... balance=90 会被阻塞，直到 TA 提交。
这样：
TA 的 UPDATE 只会修改事务开始时快照中存在的 id=1 和 id=2（假设 balance 没变）。
TA 的后续 SELECT 看到的仍然是 id=1 和 id=2（未冻结状态，但计数为2）。
结果一致了： TA 内部看到 2 个账户，UPDATE 修改了 2 个账户，SELECT 也看到 2 个账户。幻影行 id=3 根本来不及插入，避免了不一致。事务结束后，TB 才能插入 id=3，此时它的 frozen 状态是默认的 false（未被 TA 修改）。

### 3.RR解决不可重复读是基于MVCC，InnoDB的Next-Key Lock是记录锁（Record Lock）+ 间隙锁（Gap Lock）的组合，innodb中在rr下，通过Next-Key Lock解决幻读，RR解决不可重复读是基于MVCC
MVCC（多版本并发控制）是InnoDB实现快照读（Snapshot Read）的核心机制，其本质是为每个事务提供一个“一致性视图”（Read View），让事务看到的数据是事务开始时的快照
rr和rc虽然都是使用快照读，但rr是只在事务开始时生成一个数据，这个差异使得rr能解决不可重复读，而rc不行
Redo Log 确保已提交事务的修改不会丢失，而 Undo Log 确保未提交事务的修改被回滚

### 4.当前读，快照读都能解决不可重复读
1. 当前读（Current Read）
定义：读取最新并且已提交数据版本的操作，会加锁防止其他事务修改。
包括：SELECT ... FOR UPDATE（排他锁）X、SELECT ... LOCK IN SHARE MODE（共享锁）S、UPDATE、DELETE。
核心逻辑：
从Buffer Pool（内存中的数据页）读取当前最新版本（如事务B修改后的200）；
如果当前版本可见（如事务B已提交），直接返回；
如果当前版本不可见（如事务B未提交），加锁阻塞（直到事务B提交或回滚），不会读取该版本。
2. 快照读（Snapshot Read）
定义：读取历史数据版本的操作，不加锁（并发性能高）。
包括：普通SELECT语句（不加锁）。
核心逻辑：
从Buffer Pool读取当前最新版本（如事务B修改后的200）；
根据**Read View（一致性视图）**判断该版本是否可见；
如果不可见（如事务B的修改是在事务A开始后提交的），从Undo Log中回滚到可见的历史版本（如事务A开始时的100）；返回可见版本。

### 5.意向锁
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。意向锁就是解决这个问题的

意向锁是表级锁，共有两种：意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

如果要对某个表加锁，看这个表有没有意向锁，有IX锁，代表这个表有某一行已经加了X锁，此时对这个表相加S,X锁都是被阻塞

### 6.行锁表锁，排他锁共享锁，记录锁间隙锁临键锁

### 7.非主键索引注意回聚簇索引加锁
<img width="588" height="416" alt="6aea60414feb1e3192fed40e262d50d3" src="https://github.com/user-attachments/assets/2fe5f7b6-cd9f-4aa4-8a59-463755ceff21" />

唯一索引等值查询，不存在的情况，用原则1和优化2，对唯一索引加间隔锁，而由于找不到具体行，无需对聚簇索引加任何记录锁。

原则1：加锁的基本单位都是next-key lock。next-key lock（临键锁）是前开后闭区间。

原则2：查找过程中访问到的对象才会加锁。
解释原则2只有访问到的对象才会加锁，事务A的这个查询使用了覆盖索引，没有回表，并不需要访问主键索引，因此主键索引上没有加任何锁

优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁（Record lock）。

优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁（Gap lock）。

一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。



而无索引的等值查询情况，则需要逐行加锁，再根据优化原则，对于不满足条件的行解锁

### 8.什么时候向右查找
主键索引和唯一索引找到一条记录（或范围）就停止查找，不用继续向右遍历，而普通索引不确定右边还有没有能匹配的行，所以要继续向右找，根据原则2，即使这里不匹配也要加next key lock，然后可能优化

和limit限制加锁范围类似

### 9.rr和rc有什么不同
基本原则差不多，但是rc是没有gap锁的，只有行锁

### 10.当前读和不可重复读
<img width="632" height="485" alt="5fb8dd8a68053107a1d9a3caf69b0276" src="https://github.com/user-attachments/assets/f8cece28-1875-4c3f-ba88-e412105c8306" />

### 11.查询条件是非主键索引并且要回主键索引加锁的情况
<img width="534" height="487" alt="363738fba475ca5446f8950c5f74d174" src="https://github.com/user-attachments/assets/12b51916-089e-4976-837d-f436e0522a0d" />

### 12.
transaction A                                  transaction B
update t1 set name='b1' where id =6;           
                                                delete from t1 where id = 7;
A事务先执行，对主键索引中id=6的行加X record锁,同时对t1表加IX锁

B事务后执行，对主键索引中id=7的行加X record锁,同时对t1表加IX锁，两个record不是同一行，不冲突；一个是对表加的IX锁，一个是对行加，对象不一样，不冲突；只与都对t1加IX锁，IX锁是本身就是不冲突的，或者说意向锁之间就是不冲突的

加入t1有一个IX，另有一条语句对t1想要加S或X都会被阻塞
