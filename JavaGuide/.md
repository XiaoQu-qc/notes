### 1.synchronized 块和实例方法
```
public void increment() {
        synchronized (this) { // 使用 synchronized 块
            count++;
        }
    }
```
和
```
public synchronized void increment() {
 count++;
}
```
效果是一样的，但是推荐使用 synchronized 块，因为它提供了更细粒度的控制，使得在方法中只把可能发生并发冲突的代码加锁，而如果把整个方法加锁，会影响并发的程度
### 2.双重校验锁实现对象单例（线程安全）
```
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
#### (1) 
```
public  static Singleton getUniqueInstance() {

    if (uniqueInstance == null) {
      uniqueInstance = new Singleton();
    }
    return uniqueInstance;
    }
```
在单线程情况下没问题，单线程情况下同时调用getInstance这个方法肯定不行，因为A,B线程可能前后都通过判断，这样new了两侧
#### （2）去掉第一个判断条件
```
public  static Singleton getUniqueInstance() {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        return uniqueInstance;
    }
```
是可以的，只是如果单例对象已经存在，也要加锁，会影响并发程度，事实上，如果单例对象存在，直接获取就行，就像读操作一样
#### （3）去掉第二个if条件
```
public  static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                    uniqueInstance = new Singleton();
            }
        }
        return uniqueInstance;
    }
```
不行，原因和（1）一样
