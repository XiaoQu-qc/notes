### 1.synchronized 块和实例方法
```
public void increment() {
        synchronized (this) { // 使用 synchronized 块
            count++;
        }
    }
```
和
```
public synchronized void increment() {
 count++;
}
```
效果是一样的，但是推荐使用 synchronized 块，因为它提供了更细粒度的控制，使得在方法中只把可能发生并发冲突的代码加锁，而如果把整个方法加锁，会影响并发的程度
### 2.双重校验锁实现对象单例（线程安全）
```
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
#### (1) 
```
public  static Singleton getUniqueInstance() {

    if (uniqueInstance == null) {
      uniqueInstance = new Singleton();
    }
    return uniqueInstance;
    }
```
在单线程情况下没问题，单线程情况下同时调用getInstance这个方法肯定不行，因为A,B线程可能前后都通过判断，这样new了两侧
#### （2）去掉第一个判断条件
```
public  static Singleton getUniqueInstance() {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        return uniqueInstance;
    }
```
是可以的，只是如果单例对象已经存在，也要加锁，会影响并发程度，事实上，如果单例对象存在，直接获取就行，就像读操作一样
#### （3）去掉第二个if条件
```
public  static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                    uniqueInstance = new Singleton();
            }
        }
        return uniqueInstance;
    }
```
不行，原因和（1）一样
### 3.有锁的情况下读写和volatile实现无锁读写
有两个线程，一个线程修改资源，一个线程读取资源，理想情况是比如哪怕线程2先启动一点点，那么他应该读到的是修改前的资源，而如果不加锁，有可能读操作没执行完，第一个线程修改完了，这就产生了数据并发的问题。
而我们可以加锁，也可以使用volatile（换一种情况，修改线程先启动）
多线程情况下，可以区分这个key是不存在还是value=null吗
if (map.containsKey("key")) {  // 检查
    map.get(key);    // 操作
}else{
sout(没有这个key)
}
if (!map.containsKey("key")) {  // 检查键是否存在
    map.put("key", null);       // 插入 null 值
}

### 4.现代cpu调度策略
现代CPU的调度策略远比“时间片轮转”（Round-Robin）复杂，是否采用时间片轮转取决于操作系统和具体场景。也就是说cpu并不是像课本上学的那样分到时间片就从就绪态变为运行态，时间片用完就再进入就绪态，然后这样频繁的切换。
就是说现在的多线程cpu设计都是基于线程切换的，但是不一定是基于时间片切换。

### 5.jvm线程调度视角下锁发生了什么
“拿不到锁”时线程的状态变化
线程调用 lock()/mutex.lock() 失败 → 内核把它从 运行队列（runqueue） 移到 锁的等待队列（sleep/wait queue），状态设为 TASK_UNINTERRUPTIBLE 或 TASK_INTERRUPTIBLE → 当前 CPU 立即重新调度，挑下一个可运行线程。
此时原线程不再持有 CPU，也不参与调度，直到被唤醒。
“切换”由谁触发
这次切换不是“时间片到期”，而是 线程主动阻塞 触发的。调度器只是响应这一事件，与固定时间片无关。
因此：
拿不到锁 → 线程阻塞 → 立刻让出 CPU → 调度器换另一线程 这一流程成立，属于“事件驱动切换”而非时间片切换。

### 6.cas算法可以减少上下文切换，但真的能提升效率吗，一般都是cas+自旋的情况下，它确实不切换线程，但是它占用着cpu并且做无意义的等待自选？
CAS+自旋在**“临界区极短 + 竞争可控”的场景下能显著减少上下文切换，从而提升效率；
在“临界区长或竞争激烈”的场景下，空转的 CPU 时间反而成为最大开销，应退化为阻塞锁。
因此，现代库/内核都会根据实时统计信息动态选择**自旋还是阻塞，而不是一刀切。

### 7.synchronize 底层monitor实现
