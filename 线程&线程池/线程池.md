<img width="581" height="324" alt="71c485c3b9e4047bfdbef4291dff1745" src="https://github.com/user-attachments/assets/6addb565-9203-4051-9872-be075a919371" />

### 1.线程池中阻塞队列的阻塞怎么理解
线程池中阻塞队列的阻塞机制解析
线程池中的阻塞队列(BlockingQueue)的"阻塞"特性是其核心功能，主要体现在以下两个方面：


线程池的 execute/submit 永远非阻塞
队列本身不会阻塞提交者；想真正排队就必须让队列足够大，或者自己在外层用信号量/阻塞队列做二次节流。

线程池中阻塞队列的阻塞机制解析
线程池中的阻塞队列(BlockingQueue)的"阻塞"特性是其核心功能，主要体现在以下两个方面：

1. 当队列满时的生产者阻塞
当线程池的工作队列已满，并且线程池中的线程数已达到最大线程数时：提交新任务的线程(生产者)会被阻塞阻塞方式取决于线程池的拒绝策略：
默认情况下(使用ThreadPoolExecutor.CallerRunsPolicy)，提交任务的线程会尝试执行该任务使用BlockingQueue的put()方法时，线程会一直阻塞直到队列有空间
// 示例：使用put方法时的阻塞行为
blockingQueue.put(task); // 如果队列满，调用线程会在此阻塞
2. 当队列空时的消费者阻塞
当工作线程(消费者)从空队列中获取任务时：工作线程会被阻塞，等待新任务到来这种阻塞是自动的，通过BlockingQueue.take()方法实现

阻塞队列的实现原理阻塞队列通常使用以下机制实现阻塞：

ReentrantLock锁：保证线程安全
Condition条件变量：
notFull条件：队列未满时唤醒生产者
notEmpty条件：队列非空时唤醒消费者
实际线程池中的应用
在ThreadPoolExecutor中：

核心线程通过getTask()方法从队列获取任务
使用poll(keepAliveTime, TimeUnit)实现超时等待，避免核心线程永久阻塞
非核心线程在空闲超时后会被回收
理解阻塞队列的阻塞机制对于合理配置线程池参数(如队列容量、线程数等)非常重要，可以避免系统资源耗尽或任务处理效率低下的问题
