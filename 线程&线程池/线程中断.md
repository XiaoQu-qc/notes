| 任务代码                                                                       | 线程中断标志             | 任务表现                                                  | 结果                                                    |
| -------------------------------------------------------------------------- | ------------------ | ----------------------------------------------------- | ----------------------------------------------------- |
| **没有任何中断处理**<br>既没 `isInterrupted()` 也没调用可中断方法                             | 被设为 `true`         | 任务继续跑完整个 `run()`，像没发生一样；**线程被中断，但任务不鸟它**              | 看起来“突然关机”其实只是任务不理会中断，**仍然会把 run() 执行完**；线程池会等它跑完才真正退出 |
| **只调用可中断方法**<br>如 `sleep`、`take`、`lock.lockInterruptibly()`                | 被设为 `true` 或阻塞中被打断 | 阻塞方法立刻抛 `InterruptedException`，若未捕获则线程终止，**任务逻辑半路夭折** | 像“突然断电”——栈展开，finally 还能跑，但后续业务代码不再执行                  |
| **显式检测/捕获**<br>`if (isInterrupted()) ...` 或 `catch (InterruptedException)` | 被设为 `true`         | 任务自己决定：记录日志、清理资源、提前 `return`，**优雅结束**                 | 任务有机会“体面关机”，数据不丢、状态不腐                                 |
### 2.锁，线程阻塞，线程中断
比如调用lock.lockInterruptibly()，该线程如果获取不到锁，这个方法实现了，线程阻塞，以及阻塞唤醒机制由于lock是用AQS实现的，他的阻塞应该是用到了park（）？
线程阻塞和线程中断的关系看表中第二条
<img width="984" height="563" alt="83`HG 87 YV{V9%VQFT$(BS" src="https://github.com/user-attachments/assets/38c1398d-98aa-4918-94d1-e9fdf7328611" />


### 3.ABQ

### 4.线程池的用法（具体在业务中如何使用）
