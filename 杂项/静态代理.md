### 1.静态代理的作用
增强被代理对象的方法，但是不增加被代理对象的耦合度，不侵入代码
<img width="535" height="154" alt="501aba9c9a81a3c169f33ab7864ae29e" src="https://github.com/user-attachments/assets/1f163e42-8894-49a2-9791-086efc99e552" />


### 2.
当你在 `Main` 中写
SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
并调用 smsService.send("java") 时，实际会发生以下几件事（简洁版）：

- `Proxy.newProxyInstance(...)` 根据传入的类加载器和接口数组动态生成一个代理类（实现了那些接口），并返回该代理类的实例。这里的 `target.getClass().getInterfaces()` 就是告诉代理工厂“这个代理应该实现哪些接口”（因此能被强转为 `SmsService` 并在编译/运行时匹配方法签名）。
- 代理类里为接口中的每个方法生成了一个实现，方法体的实现是把调用转发给你传入的 `InvocationHandler`（即 `DebugInvocationHandler`）的 `invoke` 方法。
- 所以当你调用 `send` 时，实际上调用的是代理对象中的 `send` 实现，代理实现会调用 `handler.invoke(proxy, method, args)`，由 `invoke` 负责调用真实对象或做额外处理。

下面是一个简化的“代理类方法”示例，演示代理如何把具体方法调用转给 `InvocationHandler.invoke`：

```java
// 说明：这是简化示例，真实代理类由 JVM 动态生成
public final class $Proxy0 extends java.lang.reflect.Proxy implements SmsService {
    private static java.lang.reflect.Method m1; // 对应 send 方法的 Method 对象

    public $Proxy0(java.lang.reflect.InvocationHandler h) {
        super(h);
    }

    public void send(String msg) {
        try {
            // 转发到 InvocationHandler
            this.h.invoke(this, m1, new Object[] { msg });
        } catch (RuntimeException | Error e) {
            throw e;
        } catch (Throwable t) {
            throw new java.lang.reflect.UndeclaredThrowableException(t);
        }
    }

    // 静态块中会初始化 m1 为 SmsService.class.getMethod("send", String.class)
}
```

要点总结：
- `target.getClass().getInterfaces()` 决定了代理实现了哪些接口，影响能否强转以及哪些方法被代理。
- 代理的方法体由 JVM 生成，所有方法调用最终都会走到你传入的 `InvocationHandler.invoke`。 
- 如果目标类没有实现接口，JDK 动态代理无法代理（可用 CGLIB 等库实现类级别代理）。


### 3.这里的m1就是SmsService中的send方法对吗
是的。`m1` 是对应 `SmsService` 中 `send(String)` 那个方法的 `java.lang.reflect.Method` 对象。代理类的静态块通常会用类似 `SmsService.class.getMethod("send", String.class)` 初始化 `m1`，代理方法实现再通过 `h.invoke(this, m1, new Object[]{msg})` 把该 `Method` 传给 `InvocationHandler`。`InvocationHandler` 内调用 `method.invoke(target, args)` 就会在真实对象上执行对应签名的方法。
