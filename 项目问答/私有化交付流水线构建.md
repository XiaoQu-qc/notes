研发中台事业部/AI公共研发部/AI算力平台
实习产出：负责私有化交付自动流水线的构建，并且编写完整的操作文档
### 1.什么是私有化交付
私有化交付可以理解为：把公司开发的软件（比如文档里提到的大模型、小模型和推理服务）打包成一个“独立包裹”，然后完整地部署到客户自己的服务器或私有云环境中，而不是放在公司的公共云端。这样客户的数据和服务都在自己的“地盘”里运行，更安全可控

### 2.训练任务的主要目标是什么
训练任务的主要目标是验证打包好的代码及模型在客户实际部署环境中的可用性，而不仅仅是验证安全性。

根据文档描述，训练任务会将打包好的代码和模型下载到KAS平台进行验证，核心是确保代码和模型能适配客户指定的部署架构（如x86_nvidia或arm_910b）并正常运行。例如，不同架构的服务器硬件（如CPU型号、是否带NVIDIA显卡）可能需要不同的代码适配，训练任务就是提前在类似环境中测试这些“适配性”，避免部署到客户环境后出现无法启动、功能异常等问题。

### 3.那为什么要用ai的训练任务，直接编写一个脚本执行不是更方便吗
文档提到训练任务需根据部署架构（如x86_nvidia、arm_910b）选择，这些架构对应不同的硬件环境（如是否带NVIDIA显卡、CPU指令集差异）。AI训练任务通常内置了对不同架构的适配逻辑，例如自动调用对应硬件的驱动（如CUDA）、优化模型推理的底层库（如TensorRT），而简单脚本难以覆盖这些硬件细节。

举例：若客户使用arm架构服务器，脚本可能因缺乏底层指令集适配直接报错，而训练任务可通过预设的架构模板自动调整编译参数，确保模型在目标硬件上跑通。

镜像仓库，私有化仓库

### 4 构建镜像时遇到的问题
#### 1.原先再dockerfile中RUN pip3 config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/ \
    && pip3 install  --no-cache-dir -r requirements.txt  -i https://mirrors.wps.cn/pypi/simple --extra-index-url https://mirrors.wps.cn/pypi/dev
    requirements中的pdfcvcommon依赖只在公司镜像源中有，但是公司镜像源又无法连接，先把pdfcv pip download到本地再提交到远程仓库release-privat分支，因为Kas工作流镜像构建用的是远程仓库的代码
```
FROM hub.kce.ksyun.com/ai-kas/arm64/openeuler/openeuler_crt_python:20250710-033833

RUN dnf update -y && \
    dnf install -y gcc python3-devel make gcc-c++ && \
    dnf clean all

COPY base_dockerfile/requirements.txt requirements.txt
RUN pip3 install --no-cache-dir -r requirements.txt -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple

COPY package/ /tmp/package/
RUN pip3 install --no-cache-dir --find-links /tmp/package /tmp/package/pdfcvcommonlib-1.2.2-py3-none-any.whl && rm -rf /tmp/package
```
这样在构建镜像时，不在通过网络请求获取这些依赖包，用--find-links指定在/tmp/package中找，否则他会重新download导致出现问题

#### 2.镜像构建时经常遇到版本不一致问题，要重新编译
参与了python3.8.10魔改，要求私有化打包成镜像时，源码需要加密，原本的python没有这个功能，于是下载python3.8.10源码，修改其中的内容，上传远程仓库，打成镜像，以这个为基础镜像的话，python解释器就能执行被加密的源码

#### 3.哪些构建部分放基础镜像文件，哪些构建放到之后的
基础依赖放在基础镜像里面，这样防止重复构建镜像时重复下载，而需要用到（改动源代码或者文件的）放在后面的dockerfile文件

#### 4.（重点）使用魔改的python3.8.10镜像时出现编码错误的问题
```
chmod a+x /apps/compile_cy.sh && cd /apps && ./compile_cy.sh
python3 setup.py build_ext --inplace && #这是compile_cy.sh
```
问题出在加密后的setup.py
<img width="1412" height="42" alt="image" src="https://github.com/user-attachments/assets/7df17c35-d572-4d4e-841b-dd0d80869c57" />

先开始以为是原本的setup.py的编码格式不对，有非法字符，检查过后排除，之后想到加密前的setup.py没有非法字符，经过加密后就有非法字符可能，然后提出解决方法
1.对加密后的setup.py中的所有非法字符进行替换，不行，因为替换过后，解密后和原来的文件不一样了
2.单独把setup.py文件的未加密版本放到镜像中，不行，解释器还是指挥按原来的方法解释，先解密，再运行

然后想到先不让解释器执行setup.py，先进到镜像中看看加密后的setup.py是怎么回事，然后用file -i 发现加密后的setup.py被加密为了二进制文件，并不是utf-8.这才发现了问题所在
然后进而想到，会不会是输出Non utf8 code的函数检查时在解密函数decrypt_fopen之前执行？于是去直接用vscode自带的agent去追踪调用链，分析两个函数执行的先后关系，并且在容器中临时修改文件添加输出信息查看/。


```
这是python解释器的流程图（python3.10）
时间线 ────────────────────────────────────────────────────────────→

T0: Python 启动入口
    └─ main() [Modules/main.c]

T1: 配置和初始化
    └─ pymain_run() [main.c]
        └─ pymain_run_file(config) [main.c:356]

T2: 【关键】文件打开阶段 ⭐ ← decrypt_fopen 在这里被调用！
    └─ pymain_run_file_obj(program_name, filename, skip_source_first_line) [main.c:311]
        │
        ├─ [第一步：打开文件]
        │   _Py_fopen_obj(filename, "rb") [main.c:317]
        │   │
        │   └─ decrypt_fopen(path_bytes, "rb")  ✓✓✓
        │       │
        │       ├─ fopen(filename, "rb")
        │       ├─ 检查加密头 (ENCRYPT_HEADER)
        │       ├─ 验证 "kna_decrypt" 标记
        │       └─ 如果加密，解密并返回临时文件 fp
        │
        ├─ [检查文件类型]
        │   if (S_ISDIR(sb.st_mode)) → 错误
        │
        ├─ [跳过第一行]
        │   if (skip_source_first_line) → 处理 shebang (#!)
        │
        └─ [返回已打开的fp]

T3: 【紧接着】执行脚本
    └─ _PyRun_AnyFileObject(fp, filename, 1, &cf) [main.c:351]
        │
        └─ _PyRun_SimpleFileObject(fp, filename, 1, &cf)
            │
            ├─ maybe_pyc_file(fp, filename, 1)
            │
            └─ pyrun_file(fp, filename, ...)
                │
                ├─ _PyParser_ASTFromFile(fp, ...)
                │   │
                │   └─ _PyPegen_run_parser_from_file_pointer(fp, ...)
                │       │
                │       └─ PyTokenizer_FromFile(fp, ...)
                │           │
                │           └─ tok_readline_raw()
                │               │
                │               └─ Py_UniversalNewlineFgets(fp, ...)  ✓✓✓------>调用fgets
```
看图中3.10版本会在文件打开阶段就调用decrypt_fopen进行文件解密并且返回已经被解密的文件fp，后续处理文件时就不会有问题。问题出在3.8中,python3.8在文件打开阶段使用的_Py_wfopen()并没有调用decrypt_fopen，因此后续处理文件时会有非法字符的问题，因为没解密后的文件内容就是一堆奇奇怪怪的东西。
<img width="551" height="469" alt="image" src="https://github.com/user-attachments/assets/f30ffcc1-98d0-4306-b0b8-c8558a5f004d" />

并且我还了解到python解释器会对不同的内容用不同的函数进行处理
```
main.c: Py_Main() / Py_BytesMain()
  ↓
pymain_main()
  ↓
pymain_init()  → Py_InitializeFromConfig()
  ↓
Py_RunMain()
  ↓
pymain_run_python()
  ↓
【场景：python script.py】
  ↓
pymain_run_file(config, cf)
  ├─ PySys_Audit("cpython.run_file", ...)
  │
  └─ FILE *fp = _Py_wfopen(filename, L"rb")
     │
     ├─ 【Windows分支】
     │  └─ _wfopen() → 直接系统调用
     │
     └─ 【非Windows分支】
        ├─ wcstombs(mode) → 宽字符mode转换
        ├─ _Py_EncodeLocaleRaw(path) → 转换路径
        └─ fopen(path, mode) → 【不调用decrypt_fopen()】✗

════════════════════════════════════════════════════════

【问题】：上面的流程中，decrypt_fopen() 根本没被调用！

【原因】：_Py_wfopen() 虽然在非Windows系统上调用 fopen()，
        但它**没有集成 decrypt_fopen()**。

【真正的decrypt_fopen()入口】：应该是 _Py_fopen_obj()

但在3.8.10的pymain_run_file中，使用的是 _Py_wfopen()，
而不是 _Py_fopen_obj()。
```
